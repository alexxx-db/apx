import sys
from importlib import import_module
from pathlib import Path

from fastapi import FastAPI

from apx._core import generate_openapi


def test_generate_openapi_generates_api_ts(tmp_path: Path) -> None:
    """Test that generation creates api.ts file."""
    app_slug = "test_app"
    app_entrypoint = "test_app.backend.app:app"
    project_root = tmp_path
    src_dir = project_root / "src"
    backend_dir = src_dir / app_slug / "backend"
    ui_lib_dir = src_dir / app_slug / "ui" / "lib"
    backend_dir.mkdir(parents=True)
    ui_lib_dir.mkdir(parents=True)
    (src_dir / app_slug / "__init__.py").write_text("")
    (backend_dir / "__init__.py").write_text("")
    (backend_dir / "app.py").write_text(
        "\n".join(
            [
                "from fastapi import FastAPI",
                "",
                "app = FastAPI()",
                "",
                "@app.get('/ping')",
                "def ping():",
                "    return {'status': 'ok'}",
                "",
            ]
        )
    )

    pyproject = "\n".join(
        [
            "[tool.apx.metadata]",
            'app-name = "Test App"',
            f'app-entrypoint = "{app_entrypoint}"',
            f'app-slug = "{app_slug}"',
            'api-prefix = "/api"',
            'metadata-path = "src/test_app/backend/_metadata.py"',
            "",
        ]
    )
    (project_root / "pyproject.toml").write_text(pyproject)

    sys.path.insert(0, str(project_root))
    sys.path.insert(0, str(project_root / "src"))
    try:
        module = import_module("test_app.backend.app")
        app = getattr(module, "app")  # pyright: ignore[reportAny]
        assert isinstance(app, FastAPI)
    finally:
        sys.path.remove(str(project_root))

    generate_openapi(project_root)

    api_ts_path = ui_lib_dir / "api.ts"
    assert api_ts_path.exists()
    assert len(api_ts_path.read_text()) > 0


async def test_generate_openapi_with_rich_operations(isolated_project: Path) -> None:
    """Test OpenAPI generation with a rich set of CRUD operations."""
    from conftest import run_cli_async

    project_root = isolated_project
    src_dir = project_root / "src"
    # The app is initialized with name "test-app" which becomes slug "test_app"
    backend_dir = src_dir / "test_app" / "backend"

    # Create a backend router with rich REST operations
    router_code = """from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from .._metadata import api_prefix

api = APIRouter(prefix=api_prefix)

class Item(BaseModel):
    id: int
    name: str
    description: str | None = None
    price: float

class ItemCreate(BaseModel):
    name: str
    description: str | None = None
    price: float

class ItemUpdate(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None

# Mock database
items_db: dict[int, Item] = {}

@api.get('/items', response_model=list[Item], operation_id='listItems')
def list_items():
    '''List all items'''
    return list(items_db.values())

@api.get('/items/{item_id}', response_model=Item, operation_id='getItem')
def get_item(item_id: int):
    '''Get a specific item by ID'''
    if item_id not in items_db:
        raise HTTPException(status_code=404, detail='Item not found')
    return items_db[item_id]

@api.post('/items', response_model=Item, status_code=201, operation_id='createItem')
def create_item(item: ItemCreate):
    '''Create a new item'''
    item_id = len(items_db) + 1
    new_item = Item(id=item_id, **item.model_dump())
    items_db[item_id] = new_item
    return new_item

@api.put('/items/{item_id}', response_model=Item, operation_id='updateItem')
def update_item(item_id: int, item: ItemCreate):
    '''Replace an entire item'''
    if item_id not in items_db:
        raise HTTPException(status_code=404, detail='Item not found')
    updated_item = Item(id=item_id, **item.model_dump())
    items_db[item_id] = updated_item
    return updated_item

@api.patch('/items/{item_id}', response_model=Item, operation_id='partialUpdateItem')
def partial_update_item(item_id: int, item: ItemUpdate):
    '''Partially update an item'''
    if item_id not in items_db:
        raise HTTPException(status_code=404, detail='Item not found')
    stored_item = items_db[item_id]
    update_data = item.model_dump(exclude_unset=True)
    updated_item = stored_item.model_copy(update=update_data)
    items_db[item_id] = updated_item
    return updated_item

@api.delete('/items/{item_id}', status_code=204, operation_id='deleteItem')
def delete_item(item_id: int):
    '''Delete an item'''
    if item_id not in items_db:
        raise HTTPException(status_code=404, detail='Item not found')
    del items_db[item_id]
    return None
"""

    # Write the router code
    (backend_dir / "router.py").write_text(router_code)

    # Create the _version.py file that would normally be generated by hatch
    (src_dir / "test_app" / "_version.py").write_text('version = "0.0.0"\n')

    # Ensure .apx directory exists
    apx_dir = project_root / ".apx"
    apx_dir.mkdir(exist_ok=True)

    # Run the __generate_openapi CLI command
    result = await run_cli_async(
        [
            "__generate_openapi",
            "--app-dir",
            str(project_root),
        ],
        cwd=project_root,
    )
    exit_code = result.returncode
    if exit_code != 0:
        print(f"\n__generate_openapi exit code: {exit_code}")
        for line in result.stdout.splitlines():
            print(f"stdout: {line}")
        for line in result.stderr.splitlines():
            print(f"stderr: {line}")
        raise Exception("OpenAPI generation failed")

    # Verify and print the generated api.ts file
    api_ts_path = src_dir / "test_app" / "ui" / "lib" / "api.ts"
    assert api_ts_path.exists(), f"api.ts file not found at: {api_ts_path}"

    api_ts_content = api_ts_path.read_text()
    print("\n" + "=" * 80)
    print("Generated api.ts:")
    print("=" * 80)
    print(api_ts_content)
    print("=" * 80)

    # Verify api.ts contains expected content
    assert "import {" in api_ts_content, "api.ts should contain imports"
    assert "useQuery" in api_ts_content, "api.ts should contain useQuery"
    assert "useMutation" in api_ts_content, "api.ts should contain useMutation"
    assert "export const listItems" in api_ts_content, (
        "api.ts should contain listItems function"
    )
    assert "export function useListItems" in api_ts_content, (
        "api.ts should contain useListItems hook"
    )
